Angular 8
Type script field and property are different. Property has getter/setter, field is declared sort of like variable

Webpaack - combines all script and styles, then compress them and put them into bundle
Components - 3steps to create component. Export class, decorate with @Component, declare it in app module in declaration
	@Component has couple of properties like selector, template, style 
	Selectors are the same like in css3 (tag name, class,.. id and pseudo selectors are not working)
Service - 3 steps to create service. Export class, decorate with Injectable, class, declare it in app module in providers
To install new module, we need to NPM install that module

One way biding from component to View (DOM). Changes in DOM are not reflected in component =>
Property binding [DOM property] - bind property of DOM element to field or property from component
String Interpolation {{}} dispaying data dynamicly (property binding) usually used when we need to display string or text
Atribute binding [attr.html attribute] - atributes are used in HTMl markup. Dom properties in Dom object. They are different
Class binding [class.target class name] - bind to field or prop in components which is boolean (true or false)
Style binding [style.property of style object (ex. bacground) = "isTrue ? 'blue' : 'white'"] - bind to field or prop in components which is boolean (true or false)
Event binding (name Of event) - bind to method of our component. We can pass event object ($event)
	Take into considuration the event bubbling and to prevent it if necessary $event.stopPropagation();
	We can filter events with dit notation ex (keyup.A) to check if the key A was pressed

Template variable - we can declare template variable (usualy used with inouts) <input #email (keyup.enter)="onKeyup(email.value) />"

Two way binding [(ngModule)]; we need to declare FormsModule (is a building block in angular) in app.module in imports; 

Pipes | - are used to format the text that we want to present. We can create custom Pipe (similar like extending class in c#)

Both Input and Output makes property visable in the host component.
@Input() - Inputs are usually proerties or fields
@Output()- Outputs are usuallt events that are raised. Events are raised with new EventEmitter<type>(). when we use @Output() we need the exact same name as even
 
We use directives to manipulate with DOM object modify/change/remove
*ngIf - if evaluets to true renders the tag : not render 
*ngSwitch - evaluate to field in component. It can have default value
*ngFor(of) - similar like in javascript. It has a exported values that can be used (index, first, last, even, odd )
	By default, changes are tracked by referency in memory. We can change the tracking. trackBy: refernece to name of method
[ngClass] - object that has key value pair (usally class name and bollean)
[ngStyle] - object that has key value pair (ussualy name of the style and expression) always is better to move styles to css file
Safe traversel Operator - ? before value that we want to display. If that value is falsy it will not render. 
	If the value become truthy it will render

Creating controls - with directives (template-driven) and with code (reactive)
FormControl - for every input we need to create instance of control class (value, touched, untouched, dirty, pristine,valid, erros)
FormGroup - group of controls in a form. All the properties are the same as control

Template driven aproach
we need to inport FormsModule to be able to use ngModel
ngModel - directive used for template drieven approach. It creates formControl under the hood and we can use its properties
ngForm - it searches the tags using selector from angular and add ngForm to the tag under the hood

View encapsulation - is done automaticly from angular. It adds prefix on atributes, classes, styles.
	It can be set up in @component decorator. The atribute is encapsulation

@ViewChild() - with this decorator in front of field in ts file, we can see template variables in the ts file
	we also need to add selector (argument, name of the local reference or component) ex.: ViewChild('nameOfSelector', {static:true}) 
	static:true if inside ngOnInit : false if outside
	it return ElementRef. We acces the DOM element trough ElementRef.nativeElement 

@ContentChild() - Same as ViewChild but Instead of the view, it applyes to the content of the child

ngContent (Directive, looks like component) - it passes content add betweend opening and closing tag from the component
	It project content into the component. Most used case is when the contetn is coming from different source

LifecycleHooks:
ngOnChanges(changes: SimpleChagnges) - executed right at the start and when there is a change in field decoreted with @Input
ngOnInit - executed when initilazing the compontn (when the object is created)	
	it runs after the constructor
ngDoCheck - it is executed the most. It runs on every change (when fields or property that are bind are changed, event fired...)
ngAfterContentChecked - Called every time the projectd content has been checked
ngAfterViewInit - called every time the view have been checked
ngOnDestroy - called once component about to be destroyed

Renderer2 - we can use this component to manipulate with dom element

@Directive('selector') - we can create our own directive using the decorator.
	selector is usualy like atribute with square brackets
@HostListener('domEvenetName') - to listen for events and do some action
@HostBinding('nameOfAttribute') nameOfVariable - Binding the property of element. example:  @HostBinding('style.bacgroundColor') bacgroundColor: string = 'transparent'
* - is used for structural Directives

Services - normal class. The dont need decorator. They are injected into the construcor (dependency injection)
	we need to declare it into the @Component( providers: )
	It is Hierarchical so if we declare it in component at providers, every chiled of that parent will have acces to the instatiated object
	It is comonly put into providers in app modules
	We can use services from croos-componet comunication with rasing events and subscribing to them
@Injectable() - decoraor used on top of service, if we are injecting service into service
@Injectable({providedIn: 'root'}) - if we want to declare it right here and skip declaring in appModule providers
	

Routes and RouteModule
We need to define routs constant in appmodules as array of multiply route object {path: string, component: componentname}
path is without \ in front 
We need to import Routes to define Routes and RouteModule to declare it to angular 
we also need to put <router-outlet> where we want to render the component from the routs

We use this in template (html file)
routerLink directive - declare name of the roots, render componentand prevent page from Reloading
	it can have array of values if we use property binding ex. [routeLink]= "['/nameOfabsoluteRoute', 'nameOfappendedRoot']"
	with leading /, we declare absolute path. Without /, we use relative path of our current loaded path
	we can specify path like folders pat. ex. ../nameOfRoot
[queryParams] - it allows us to add query parameters into the link. We are passing object key-value pairs
[fragment] - allows us to add anker point at our web. the value is set up on directly

routerLinkActive directive - it allow us to set class on our links when we click. It is usually used for active class
routerLinkActiveOptions - is used to specify the "exact" option about the link ex.p [routerLinkActiveOptions] = "{exact: true}"

route.navigate() - method we use to navigate to different paths. It accepts multiply parameters (path, query params etc)
	ex. route.navigate(['/server', id, 'edit'], {queryParams: {allowEdit: 1}, fragment: loading })
 	we can use also relative path with .navigate(['edit'], {relativeTo: this.roue}) 
	to preserve query params we use property {queryParamsHandling: 'merge' or 'preserve'}. 
	merge is merging the queryParams with the new querryParams. preserve is preserving the old ones and drop out the new ones

To acess the option of the Router object we need to inject it into the constructor of the component.
ActivatedRoute interface - give us a lot of meata bout the activated rout ActivatedRoute 
Passing parametars in root just like MVC :?id into root declaration. 
Accessing them is trough ActivatedRoute (.snapshot.params(object) or .params(observable))

nested router path - {path: "users", component: nameComponent, children: [{path: , component}}}
	we can nest routes by adding property children (array) after rendering component 	
	then we need to add <router-outlet> where we want to render that components
	redirectTo - instead of specifying a component to render, we can use the property 
Wildcard Routes - we can riderect the routes that are not found in our specification with '**'
	we need to put the wild card path as the last route. 
path matching - we can redirect at exact path { path: '', redirectTo: '/somewhere-else', pathMatch: 'full' }

Outsourcing the routs - it is done automaticly when creating new project and selecting add roouter
	we can transfer it manualy in diferet file using routerModule

Angular is destroying component and cleariing unnecessary data. Usually we need do use lifecycleHook ngOnDestry to remove
any subscription (unsubscribe) that we made. The subscription is not clously tight with the component

canActivate - we use this for AuthGuard and Auth service. it protects the rote and all the child routs
	We create sevice and before loading of new rout, we can acess canAcivete and check for if user can acces the rote page
	After creating the services, we need to add property canActivete where we are specifing the rotes
	and pass into an array which service we will use. ex.p {path: '/', canActivate[AuthGuard] component: name}
	after all of that we need to declare it into app modules providers

canActivateChild - to protected the children (nested) routs. Same like canActivate. 
	needs to be set in path rotes like property canActivateChild

canDeactivate - we use this to prevent changing route path. In order to use canDeactivate method in component,
	we need to create interface which has canDeactivate method. Then our component need to impliment that interface
	and provide the logic in canDeactivate method

Static data to Router - we set property data where we declare our routes path 
	ex. {path: "/", component: name, data: {message: 'Page not found'}}
	We acces this data from ActivatedRoute
 

Dynamic data to Router - we need to create another servise which implements Resolve<type>
	to revisit this again...

HttpClientModule - In order to work with http request, we need to declare in imprts HttpClientModule in app modules 
	we inject HttpClient in our component and them we can use it to make http request. It returns Observable. 
	all methods are of generic type. That means after the name in bracket we can specify the type
	ex. HttpClient.get<typeOfResponse>
	It is a good practice to show loader while witing for response from server.
	This is done with simple flag
HttpClient.post - method to send post request. It needs parameter like url and body(what we are sending).
	The body is usually a Json object. At the end we need to subscribe to the post method. The method completes after execution
HttpClient.get - takes url and we need to subscribe 
HttpClient.delete - takes url. It is executed only if it succeed.

We are using this methods in pipe (outside of error funcion on subscribe) catch is like a pipe method
catchError and throwError - catchError  imported from rxjs/operator. throwError imported from rxjs 
	We use catchError method to log errors or analize them in our backend
	error needs to be able to reach subscribe. So when we catch the error we need to throw it back
	ex.  catchError(err => {...Logic return throwError(errodResult) })
Setting Headers - HttpHeaders needs to be inported. At the end of every method, we can add argument (object) to configure
	a lot of properties for the request. One of the properties is headers

Interceptors - intercepts all ongoig requests and run some logic before the request leaves our app.	
	usually it is used for authentication user attaching the token to the requests
	implements HttpInceptor. intercept(req: HttpRequest<any>, next: HttpHandler){ return next.handle(req)}
	we need to call the function next to send the request to desired place
	We declare this service in the providers on a special way ex.p providers: [{ provide: HTTP_INTERCEPTORS, useClass: serviceName, multi: true}]
	We are setting multy to true if we are going to use multiply interceptors and dont want for them to ovveride eachother
	The request object is immutuble. We use clone() if we want to change some properties
Multiple Interceptor - They are executed in the order that we declare them in appModule providers array




